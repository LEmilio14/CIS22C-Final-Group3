
template <typename T>
BinaryTreeNode<T> * AVLTree<T>::get_rp_add_rem(const T & i_item)
{
	Stack1<BinaryTreeNode<T> *> stack_tt;
	BinaryTreeNode<T> * t_ptr = BinarySearchTree<T>::root_ptr, *tt_ptr = t_ptr;
	int balanced_factor;
	while (true)
	{
		if (t_ptr->datum > i_item)
		{
			balanced_factor = get_balanced_factor(t_ptr);
			if (balanced_factor != -1 && balanced_factor != 0 && balanced_factor != 1)
			{
				stack_tt.push(tt_ptr);
			}
			tt_ptr = t_ptr;
			if (t_ptr->left_ptr == nullptr)
			{
				break;
			}
			t_ptr = t_ptr->left_ptr;
		}
		else
		{
			balanced_factor = get_balanced_factor(t_ptr);
			if (balanced_factor != -1 && balanced_factor != 0 && balanced_factor != 1)
			{
				stack_tt.push(tt_ptr);
			}
			tt_ptr = t_ptr;
			if (t_ptr->right_ptr == nullptr)
			{
				break;
			}
			t_ptr = t_ptr->right_ptr;
		}
	}
	if (stack_tt.isEmpty_stack())
	{
		return nullptr;
	}
	else
	{
		return stack_tt.peek();
	}
}

template <typename T>
void AVLTree<T>::get_path_stack(Stack1<BinaryTreeNode<T> *> & stack, const T & i_item)
{
	BinaryTreeNode<T> * temp = BinarySearchTree<T>::root_ptr;
	while (temp->datum  != i_item)
	{
		stack.push(temp);
		if (temp->datum > i_item)
		{
			temp = temp->left_ptr;
		}
		else
		{
			temp = temp->right_ptr;
		}
	}
	return;
}

template <typename T>
void AVLTree<T>::rotate_rem(BinaryTreeNode<T> * rp_ptr, BinaryTreeNode<T> * r_ptr)
{
	if (BinarySearchTree<T>::get_height_r(r_ptr->left_ptr) > BinarySearchTree<T>::get_height_r(r_ptr->right_ptr))
	{
		if (BinarySearchTree<T>::get_height_r(r_ptr->left_ptr->left_ptr) > BinarySearchTree<T>::get_height_r(r_ptr->left_ptr->right_ptr))
		{
			/*
			left-left
			*/
			rotate_right(rp_ptr, r_ptr);
		}
		else // BinarySearchTree<T>::get_height_r(r_ptr->left_ptr->left_ptr) <= BinarySearchTree<T>::get_height_r(r_ptr->left_ptr->right_ptr)
		{
			/*
			left_right
			*/
			rotate_left(r_ptr, r_ptr->left_ptr);
			rotate_right(rp_ptr, r_ptr);
		}
	}
	else // BinarySearchTree<T>::get_height_r(r_ptr->left_ptr) < BianrySearchTree<T>::get_height_r(r_ptr->right_ptr)
	{
		if (BinarySearchTree<T>::get_height_r(r_ptr->right_ptr->left_ptr) > BinarySearchTree<T>::get_height_r(r_ptr->right_ptr->right_ptr))
		{
			/*
			right-left
			*/
			rotate_right(r_ptr, r_ptr->right_ptr);
			rotate_left(rp_ptr, r_ptr);
		}
		else // BinarySearchTree<T>::get_height_r(r_ptr->right_ptr->left_ptr) <= (BinarySearchTree<T>::get_height_r(r_ptr->right_ptr->right_ptr)
		{
			/*
			right-right
			*/
			rotate_left(rp_ptr, r_ptr);
		}
	}
}

template <typename T>
bool AVLTree<T>::remove_avl(const T & i_item)
{
	bool result = BinarySearchTree<T>::remove(i_item);
	int balanced_factor;
	if (result == true)
	{
		if (isEmpty_avl()) // == 0
		{}
		else
		{
			BinaryTreeNode<T> * unbalanced_root_parent = get_rp_add_rem(i_item), *unbalanced_root = nullptr;
			Stack1<BinaryTreeNode<T> *> path_stack;
			// find out the unbalacned_root from unbalanced_root_parent
			if (unbalanced_root_parent == nullptr) // >= 1
			{
			}
			else // >= 3
			{
				if (unbalanced_root_parent->left_ptr != nullptr && unbalanced_root_parent->right_ptr != nullptr)
				{
					balanced_factor = get_balanced_factor(unbalanced_root_parent->left_ptr);
					if (balanced_factor != -1 && balanced_factor != 0 && balanced_factor != 1)
					{
						unbalanced_root = unbalanced_root_parent->left_ptr;
					}
					else
					{
						balanced_factor = get_balanced_factor(unbalanced_root_parent->right_ptr);
						if (balanced_factor != -1 && balanced_factor != 0 && balanced_factor != 1)
						{
							unbalanced_root = unbalanced_root_parent->right_ptr;
						}
						else
						{
							unbalanced_root = unbalanced_root_parent;
						}
					}
				}
				else if (unbalanced_root_parent->left_ptr != nullptr)
				{
					balanced_factor = get_balanced_factor(unbalanced_root_parent->left_ptr);
					if (balanced_factor != -1 && balanced_factor != 0 && balanced_factor != 1)
					{
						unbalanced_root = unbalanced_root_parent->left_ptr;
					}
					else
					{
						unbalanced_root = unbalanced_root_parent;
					}
				}
				else
				{
					balanced_factor = get_balanced_factor(unbalanced_root_parent->right_ptr);
					if (balanced_factor != -1 && balanced_factor != 0 && balanced_factor != 1)
					{
						unbalanced_root = unbalanced_root_parent->right_ptr;
					}
					else
					{
						unbalanced_root = unbalanced_root_parent;
					}
				}
				// get the path stack from root to unbalanced_root
				get_path_stack(path_stack, unbalanced_root->datum);
				rotate_rem(unbalanced_root_parent, unbalanced_root);
				BinaryTreeNode<T> * trial;
				while (!path_stack.isEmpty_stack())
				{
					trial = path_stack.peek();
					balanced_factor = get_balanced_factor(trial);
					if (balanced_factor == -1 || balanced_factor == 0 || balanced_factor == 1)
					{
						path_stack.pop();
					}
					else
					{
						if (path_stack.size_stack() == 1)
						{
							unbalanced_root = path_stack.peek();
							path_stack.pop();
							unbalanced_root_parent = unbalanced_root;
							rotate_rem(unbalanced_root_parent, unbalanced_root);
						}
						else
						{
							unbalanced_root = path_stack.peek();
							path_stack.pop();
							unbalanced_root_parent = path_stack.peek();
							rotate_rem(unbalanced_root_parent, unbalanced_root);
						}
					}
				}
			}
		}
	}
	if (get_nodes_num_avl() <= 100)
	{
		check_balanced();
		std::cout << std::endl << get_height_avl() << std::endl;
		std::cout << get_nodes_num_avl() << std::endl;
		std::cout << std::endl << "******************************************************************************************************************" << std::endl << std::endl;
	}
	return result;
}